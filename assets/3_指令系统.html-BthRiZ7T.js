import{_ as i,c as a,a as e,o as n}from"./app-C6qutNXP.js";const t={};function h(r,l){return n(),a("div",null,l[0]||(l[0]=[e('<h1 id="_3-指令系统" tabindex="-1"><a class="header-anchor" href="#_3-指令系统"><span>3 指令系统</span></a></h1><h2 id="操作地址码" tabindex="-1"><a class="header-anchor" href="#操作地址码"><span>操作地址码</span></a></h2><h2 id="汇编语言" tabindex="-1"><a class="header-anchor" href="#汇编语言"><span>汇编语言</span></a></h2><p>有两种转换方式：“编译”和“解释”</p><ol><li>编译程序compiler:将</li></ol><p>机器指令基本格式： 指令的基本格式：|操作码|地址码| 操作码：指明操作的性质与功能 地址吗：操作数地址</p><p>指令长度：尽可能短、等于字节的整数倍</p><h3 id="地址吗结构" tabindex="-1"><a class="header-anchor" href="#地址吗结构"><span>地址吗结构</span></a></h3><p>双操作数指令，除了操作码以外，还包含以下信息：</p><ul><li>第一操作数的地址 A1</li><li>第二操作数的地址 A2</li><li>操作结果存放地址 A3</li><li>下条要执行指令的地址 A4 显地址：信息在指令中明显给出 隐地址：某种事先约定给地址</li></ul><h3 id="四指令地址" tabindex="-1"><a class="header-anchor" href="#四指令地址"><span>四指令地址：</span></a></h3><table><thead><tr><th>OP</th><th>A1</th><th>A2</th><th>A3</th><th>A4</th></tr></thead><tbody><tr><td>+</td><td>100</td><td>200</td><td>300</td><td>400</td></tr></tbody></table><p>(A1)OP(A2)-&gt;A3<br> A4 = 下条将要执行指令的地址</p><h3 id="三地址指令" tabindex="-1"><a class="header-anchor" href="#三地址指令"><span>三地址指令：</span></a></h3><p>|OP|A1|A2|A3|</p><p>(A1)OP(A2)-&gt;A3<br> (PC)+1 = 下条将要执行指令的地址<br><strong>指令需4次访问主存</strong></p><h3 id="二地址指令" tabindex="-1"><a class="header-anchor" href="#二地址指令"><span>二地址指令</span></a></h3><p>|OP|A1|A2|<br> (A1)OP(A2)<br> (PC+1)=1下条将要执行指令的地址<br><strong>指令需4次访问主存</strong> mov指令三次访问 运算指令4次访问</p><h3 id="一地址指令" tabindex="-1"><a class="header-anchor" href="#一地址指令"><span>一地址指令</span></a></h3><p>|OP|A1| (AC)OP(A1)-&gt;(AC) (PC+1)=1下条将要执行指令的地址<br><strong>指令需2次访问主存</strong></p><h3 id="零地址指令" tabindex="-1"><a class="header-anchor" href="#零地址指令"><span>零地址指令</span></a></h3><p>操作数地址是隐含的，操作数、运算结果在堆栈中。</p><p>一地址格式好；三地址指令编写的程序最短</p><p>例题：</p><h3 id="指令的操作码" tabindex="-1"><a class="header-anchor" href="#指令的操作码"><span>指令的操作码</span></a></h3><p>每一条指令都有唯一确定的操作码。 指令操作码可以分为：</p><ol><li><p>规整性（定长编码） 操作码字段的位数和位置固定</p></li><li><p>非规整性（变长编码） 操作码字段的位数不固定，分散</p></li></ol><h3 id="核心考点" tabindex="-1"><a class="header-anchor" href="#核心考点"><span>核心考点</span></a></h3><p>最常用的编码方式是<strong>扩展操作码法</strong></p><ul><li>让操作数地址个数多的指令的操作码字段短些，操作数地址个数少的指令（如一或零地址指令）的操作码字段长些</li></ul><p>扩展操作码示例：</p><p>|OP|A1|A2|A3|(都是4位)<br> 0000 XXXX YYYY ZZZZ<br> 1110 XXXX YYYY ZZZZ 有15条三地址指令<br> 1111 0000 XXXX YYYY<br> 1111 1110 XXXX YYYY 有15条二地址指令<br> 1111 1111 0000 XXXX<br> 1111 1111 1110 XXXX 有15条一地址指令<br> 1111 1111 1111 0000<br> 1111 1111 1111 1111 有16条零地址指令</p><p>要点：短码不能是长吗的前缀，各条指令的操作码唯一</p><p>指令操作码的优化: 足够表达全部指令的前提下，使操作码字段占用的位数最少。\\</p><p>优化操作码举例： Huffman编码</p><ol><li>所有指令按照操作码在程序中出现的概率，自左向右从小排到大</li></ol><p>平均码长=。。。</p><p>Huffman编码（最优编码），存在主要缺点：</p><h3 id="寻址技术" tabindex="-1"><a class="header-anchor" href="#寻址技术"><span>寻址技术</span></a></h3><p>寻址技术包括编址地址和</p><ol><li>啊啊</li><li>啊啊</li><li>指令中地址码的位数 <strong>每个地址码的位数与主存容量和最小寻址单位（编址单位）有关联</strong> 主存容量是2^20字节，机器字长32位。 最小寻址单位为字节，地址码只需20位 最小寻址单位位字，地址码只需18位</li></ol><p>基本的数据寻址方式</p><ol><li>立即寻址 |OP|立即数|</li><li>寄存器寻址 指令中地址码部分给出某一通用寄存器的编号，所指定的寄存器中存放着操作数 两个明显的优点： <ul><li>从寄存器存取数据比主存快得多</li><li>由于</li></ul></li><li>直接寻址(绝对寻址) 指令中地址吗字段给出的地址A就是操作数的有效地址 EA=A</li><li>间接寻址 EA=（A） @=0 直接寻址 @=1 间接寻址 优点： <ol><li>扩大了寻址范围</li><li>可将主存单元作为程序的地址指针</li></ol></li><li>寄存器间接寻址 指令中的地址码给出</li><li>变址寻址 EA = A+Rx Rx为变址值</li><li>基址寻址 基址寻址和变址寻址的区别： <ul><li>应用的场合不一样，变址面向用户；基址寻址</li></ul></li><li>相对寻址 EA = (PC)+D 特点：操作数的地址不是固定的</li><li>页面寻址 <ul><li>将整个主存空间分成若干个大小相同的区，每个区称为一页。</li><li>每页有若干个主存单元，每页都有自己的编号（页面地址）</li></ul></li></ol><p>各类数据寻址方式获得数据的速度（由快到慢）： 立即寻址&gt;寄存器寻址&gt;直接寻址&gt;寄存器间接寻址&gt;页面寻址&gt;变址寻址（基址寻址、相对寻址）&gt;一级间接寻址&gt;多级间接寻址</p><h3 id="堆栈与堆栈操作" tabindex="-1"><a class="header-anchor" href="#堆栈与堆栈操作"><span>堆栈与堆栈操作</span></a></h3><p>LIFO FIFO</p><p>堆栈类型：</p><ol><li>寄存器堆栈（硬堆栈）</li><li>存储器堆栈 SP栈指针（栈指针所指定的操作）</li></ol><p>出栈时，需要先将堆栈中的数据弹出，然后SP的内容再自动加一<br> ((SP))</p><p>x = (axb+c-d)/(e+f) PUSH A PSUH B MUL PUSH C ADD PUSH D SUB PUSH E PUSH F ADD DIV POP X</p><p>12条指令，进出栈指令共3次访问。</p><p>指令类型： <strong>数据传说类指令</strong>主要用于实现寄存器与寄存器之间，寄存器与主存单元之间</p><ol><li><p>主存单元之间的传送</p></li><li><p>从主存单元传送到寄存器</p></li><li><p>从寄存器传送到主存单元</p><ol start="2"><li>堆栈指令操作（-）</li></ol></li></ol><h3 id="运算类指令" tabindex="-1"><a class="header-anchor" href="#运算类指令"><span>运算类指令（-）</span></a></h3><h3 id="逻辑运算类指令举例" tabindex="-1"><a class="header-anchor" href="#逻辑运算类指令举例"><span>逻辑运算类指令举例</span></a></h3><ol><li>按位测（位检查）</li><li>按位修改 <ul><li>利用“异或”指令可以修改目的操作数</li></ul></li><li>移位指令 <ul><li>算术移位</li></ul></li></ol><h3 id="程序控制类指令" tabindex="-1"><a class="header-anchor" href="#程序控制类指令"><span>程序控制类指令</span></a></h3><h4 id="子程序调用指令" tabindex="-1"><a class="header-anchor" href="#子程序调用指令"><span>子程序调用指令</span></a></h4><p>子程序是一组可以公用的指令序列，只要知道子程序的入口地址就能调用他</p><ul><li>从主程序转向子程序的指令称为子程序调用指令(CALL);从子程序转向主程序</li></ul><p>子程序调用和转移指令区别</p><h3 id="子程序嵌套" tabindex="-1"><a class="header-anchor" href="#子程序嵌套"><span>子程序嵌套</span></a></h3>',62)]))}const s=i(t,[["render",h],["__file","3_指令系统.html.vue"]]),d=JSON.parse('{"path":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3_%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.html","title":"3 指令系统","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"操作地址码","slug":"操作地址码","link":"#操作地址码","children":[]},{"level":2,"title":"汇编语言","slug":"汇编语言","link":"#汇编语言","children":[{"level":3,"title":"地址吗结构","slug":"地址吗结构","link":"#地址吗结构","children":[]},{"level":3,"title":"四指令地址：","slug":"四指令地址","link":"#四指令地址","children":[]},{"level":3,"title":"三地址指令：","slug":"三地址指令","link":"#三地址指令","children":[]},{"level":3,"title":"二地址指令","slug":"二地址指令","link":"#二地址指令","children":[]},{"level":3,"title":"一地址指令","slug":"一地址指令","link":"#一地址指令","children":[]},{"level":3,"title":"零地址指令","slug":"零地址指令","link":"#零地址指令","children":[]},{"level":3,"title":"指令的操作码","slug":"指令的操作码","link":"#指令的操作码","children":[]},{"level":3,"title":"核心考点","slug":"核心考点","link":"#核心考点","children":[]},{"level":3,"title":"寻址技术","slug":"寻址技术","link":"#寻址技术","children":[]},{"level":3,"title":"堆栈与堆栈操作","slug":"堆栈与堆栈操作","link":"#堆栈与堆栈操作","children":[]},{"level":3,"title":"运算类指令（-）","slug":"运算类指令","link":"#运算类指令","children":[]},{"level":3,"title":"逻辑运算类指令举例","slug":"逻辑运算类指令举例","link":"#逻辑运算类指令举例","children":[]},{"level":3,"title":"程序控制类指令","slug":"程序控制类指令","link":"#程序控制类指令","children":[]},{"level":3,"title":"子程序嵌套","slug":"子程序嵌套","link":"#子程序嵌套","children":[]}]}],"git":{"updatedTime":null,"contributors":[]},"filePathRelative":"计算机组成原理/3_指令系统.md"}');export{s as comp,d as data};
